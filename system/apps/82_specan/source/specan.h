/*
 * Copyright 2010 Michael Ossmann
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

/*
 * There is one channel per column of the display.  The radio is tuned to one
 * channel at a time and RSSI is displayed for that channel.
 */

#include <stdint.h>




#define NUM_CHANNELS 132

/*
 * wide mode (default): 44 MHz on screen, 333 kHz per channel
 * narrow mode: 6.6 MHz on screen, 50 kHz per channel
 */
#define WIDE 0
#define NARROW 1
#define ULTRAWIDE 2

/*
 * short mode (default): displays RSSI >> 2
 * tall mode: displays RSSI
 */
#define SHORT 0
#define TALL 1

/* vertical scrolling */
#define SHORT_STEP  16
#define TALL_STEP   4
#define MAX_VSCROLL 120
#define MIN_VSCROLL 0

/* frequencies in MHz */
#define DEFAULT_FREQ     440
#define WIDE_STEP        5
#define NARROW_STEP      1
#define ULTRAWIDE_STEP   20
#define WIDE_MARGIN      13
#define NARROW_MARGIN    3
#define ULTRAWIDE_MARGIN 42

/* frequency bands supported by device */
#define BAND_300 0
#define BAND_400 1
#define BAND_900 2

/* band limits in MHz */
#define MIN_300  281
#define CEN_300	 315
#define MAX_300  361
#define MIN_400  378
#define CEN_400	 435
#define MAX_400  481
#define MIN_900  749
#define CEN_900	 855
#define MAX_900  962

/* band transition points in MHz */
#define EDGE_400 369
#define EDGE_900 615

/* VCO transition points in Hz */
#define MID_300  318000000
#define MID_400  424000000
#define MID_900  848000000

/* channel spacing in Hz */
#define WIDE_SPACING      199952
#define NARROW_SPACING    49988
#define ULTRAWIDE_SPACING 666504

/* display peaks long enough to be seen (don't set higher than 20) */
#define PERSIST 8

/* power button debouncing for wake from sleep */
#define DEBOUNCE_COUNT  4
#define DEBOUNCE_PERIOD 50

#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
#define MAX(a, b)  (((a) > (b)) ? (a) : (b))




/* bitmaps */
static const uint8_t narrow_ruler[] = {
	0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02,
	0xFE, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02,
	0x3E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02,
	0xFE, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02,
	0x3E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02,
	0xFE, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02,
	0x3E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02,
	0xFE, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02,
	0x3E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02,
	0xFE, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02,
	0x3E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02,
	0xFE, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02,
	0x3E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02, 0x0E, 0x02,
	0xFE, 0x02, 0x0E, 0x02, 0x0E, 0x02
};

static const uint8_t wide_ruler[] = {
	0x02,
	0x0E, 0x02, 0x02, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x02, 0x02,
	0xFE, 0x02, 0x02, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x02, 0x02,
	0x3E, 0x02, 0x02, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x02, 0x02,
	0xFE, 0x02, 0x02, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x02, 0x02,
	0x3E, 0x02, 0x02, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x02, 0x02,
	0xFE, 0x02, 0x02, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x02, 0x02, 0x0E,
	/* extra to accommodate offset starting point */
	0x02, 0x02, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x02, 0x02,
	0x3E, 0x02, 0x02, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x02, 0x02, 0x0E
};

static const uint8_t ultrawide_ruler[] = {
	0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0xFE, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0xFE, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0xFE, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0xFE, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0xFE, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0xFE, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0xFE, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0xFE, 0x02, 0x02, 0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0x0E, 0x02, 0x02, 0x0E, 0x02, 0x02,
	0xFE, 0x02, 0x02, 0x0E, 0x02, 0x02
};

/* Keeping track of all this for each channel allows us to tune faster. */
typedef struct {
	/* frequency setting */
	uint8_t freq2;
	uint8_t freq1;
	uint8_t freq0;
	
	/* frequency calibration */
	uint8_t fscal3;
	uint8_t fscal2;
	uint8_t fscal1;

	/* signal strength */
	uint8_t ss[PERSIST];
	uint8_t max;
	uint8_t last_drawn;
} channel_info;


/* globals */
extern channel_info chan_table[NUM_CHANNELS];
extern uint16_t center_freq;
extern uint16_t user_freq;
extern uint8_t band;
extern uint8_t width;
extern char max_hold;
extern char height;
extern char sleepy;
extern uint8_t vscroll;
extern uint8_t min_chan;
extern uint8_t max_chan;
extern uint8_t sweep;
extern uint8_t persistence;

void clear();
void plot(uint8_t col);
uint8_t getkey();
void draw_ruler();
void draw_freq();
void radio_setup();
void set_filter();
void set_radio_freq(uint32_t freq);
void calibrate_freq(uint32_t freq, uint8_t ch);
uint16_t set_center_freq(uint16_t freq);
void tune(uint8_t ch);
void init_all();
void set_width(uint8_t w);